# 读书笔记：《Java 性能权威指南》

## 知识点

### 性能测试
本文介绍了性能测试的4个原则

#### 1.测试真实应用（在实际使用的环境中进行性能测试）

> a.微基准测试：用来测试微小单元的性能，包括调用同步方法的用时与非同步方法的用时比较，创建线程的代价与使用线程池的代价，执行某种算法的的耗时与其替代实现的耗时，等等。
> 
>> 被测试代码的结果必须被使用到，不然被测试代码会被编译器优化掉，不进行运行，得不到实际测试效果
>>
>> 被测试代码中不要包含无关操作
>> 
>> 测试过程必须输入合理参数，有的参数导致O(1000)复杂度，有的参数操作只有O(1)
>>
>> 微基准测试需要热身期：Java的一个特点是代码执行的越多性能越好
> 
> b.宏基准测试：衡量应用性能最好的事物就是应用本身，以及它用到的外部资源
> 
> c.介基准测试：测试某方面性能的基准测试，但仍要执行大量代码

#### 2.理解批处理流逝时间、吞吐量和响应时间：应该测量哪个指标取决于对应应用最重要的因素

> a.批处理流逝时间：Java由于即时编译（JIT）机制中，虚拟机会花几分钟（或更长时间）全面优化代码并以最高性能执行；因此Java性能测试需要关注热身期：编译优化；缓存
> 
> b.吞吐量测试：一定时间内所能完成的工作量，TPS、RPS、OPS
> 
> c.响应时间测试：从客户端发送请求到收到响应之间的流逝时间，P95

#### 3.用统计方法应对性能变化

> a.学生t检验

#### 4.尽早频繁测试

> a.自动化一切：脚本化或程序化
> 
> b.测试一切：CPU使用率、磁盘使用率、网络使用率、内存使用率
> 
> c.在真实系统上运行

### JIT 编译
即时编译器（Just-In-Time, JIT）是Java虚拟机的核心

#### 编译器工作原理
> a.编译型语言（C++、Fortran）：程序以二进制形式交付，写完的程序被编译器静态编译成二进制文件，二进制文件中的汇编码是针对特定CPU的，只有兼容的CPU才能执行
> 
> b.解释型语言（PHP、Perl）：只要机器上有合适的解释器，相同的程序代码可以在任何CPU上运行，执行程序时，解释器会将相应代码转换成二进制代码
> 
> c.即时编译：Java应用先被编译成一种理想化的汇编语言，然后该汇编语言（Java字节码）可以用java（相当于解释器）运行

#### JIT编译器优缺点
> a.client(C1编译器)：开启编译比server要早，编译出的字节码比server多，在代码执行的开始阶段，client编译器比server编译器要快
> 
> b.server(C2编译器)：server编译器在编译代码时，比client优化得更好，生成的代码比client快
> 
> c.分层编译：代码先由client编译器编译，启动后随着代码变热，由server编译器重新编译


#### 编译器中级调优
> a.调优代码缓存：JVM编译代码时，会在代码缓存中保留编译之后的汇编语言指令集，如果缓存太小，JVM就不能编译更多代码了，导致运行耗时增加
> 
> b.编译阈值：代码执行达到一定次数，且达到了编译阈值，触发编译器编译代码，编译是基于两种JVM计数器的（方法调用计数器和方法中的循环回边计数器
> 
> c.检查汇编过程：+PrintCompilation(默认为false)

#### 高级调优
> a.通过调整编译线程数来提高编译速度：
> 
>> 放置在编译队列中的方法的编译会被异步执行
>>
>> 队列并不是严格按照先后顺序进行的；队列中的热点方法会在其他方法之前编译，这是编译输出日志中的ID为乱序的原因之一
> 
> b.内联
> 
>> 内联是编译器能做到的最有利的优化，特别是对属性封装良好的面向对象的代码来说
>> 
>> 几乎用不着调节内联参数，且提倡这样做的建议往往忽略了常规内联和频繁调用内联之间的关系
> 
> c.逃逸分析：开启逃逸分析，server编译器会执行一些非常激进的优化措施
> 
>> 逃逸分析是编译器能做得最复杂的优化，此类优化常常会导致微基准测试失败
>>
>> 逃逸分析常常会给不正确的同步代码引入 bug
> 
> d.逆优化：编译器不得不撤销某些优化效果
> 
>> 代码被丢弃(made not entrant)
>>
>> 产生僵尸代码(made zombie)

#### 分成编译级别
> 分层编译可以在两种编译器和5种级别之间进行
> 
> 不建议人为更改级别

### 垃圾收集

#### Throughput收集器
> Throughput收集器会进行两种操作：Minor GC和Full GC
> 
> 通过GC日志中的时间输出，我们可以迅速地判断出Throughput收集器的GC操作对应程序总体性能的影响
> 
> Throughput收集器的调优几乎都是围绕停顿时间进行的，寻求堆的总体大小、新生代的大小以及老年代大小之间的平衡（静态调整）
> 
> GCTimeRation可以设置应用在垃圾回收上话费的时间比例（动态调整）

#### CMS收集器
> CMS会对新生代的对象进行回收（所有的应用线程会被暂停）
> 
> CMS会启动一个并发的线程堆老年代空间的垃圾进行回收
> 
> 如果有必要，CMS会发起Full GC
> 
> CMS有多个操作，但是期望的操作是Minor GC和并发回收
> 
> 避免发生并发模式失效是提升CMS处理能力、获得高性能的关键
>
>> 最简单的方法是增大堆的容量
>>
>> 通过调整CMSInitiatingOccupancy-Fraction参数，尽早启动并发后台线程的运行
>>
>> 调整后台线程数目
> 
> 应用在CPU资源受限的机器上运行，同时又要求较小的停顿，这时使用增量式CMS收集器是一种不错的选择
> 
> 通过责任周期可以调整增量CMS收集器；增加责任周期的运行时间可以避免CMS收集器发生并发模式失效

#### G1收集器

> G1收集器主要活动
> 
>> 新生代垃圾收集
>>
>> 后台收集，并发周期
>>
>> 混合式垃圾收集
>>
>> 必要时的Full GC
> 
> 调优良好的JVM运行G1收集器时应该只经历新生代周期、混合式周期和并发GC周期
> 
> G1的并发阶段会产生少量的停顿
> 
> 恰当的时候，我们需要对G1进行调优，才能避免Full GC周期发生

#### 虚拟机类型(与平台的默认JVM编译器相关，决定了平台默认的垃圾收集器)
* Client 类: Windows 上运行的任何32位JVM，以及单CPU机器上运行的任何32位JVM，都是Client类虚拟机
* Server 类：其他机器都被认为是Server类

### Java 堆内存使用

#### 内存溢出错误
> JVM原生内存不足
> 
> 永久代（Java7及更早版本）或元空间（Java8）内存不足
> 
> Java堆本身内存不足-对于给定的堆空间而言，应用中活跃对象太多
> 
> JVM执行GC耗时太多

### 线程性能调优

#### ThreadPoolExecutor
> 线程初始化成本很高，线程池使得系统上的线程容易控制
> 
> 线程池必须仔细调优
> 
> 在使用ThreadPoolExecutor，选择更简单的选项通常会带来最好的、最能预见的性能

#### ForkJoinPool
> ForkJoinPool是为了配合分治算法的使用而设计的，任务可以递归地分解为子集；这些子集可以并行处理，然后归并到一个结果中
> 
> ForkJoinPool实现了工作窃取
> 
> Java8依赖ForkJoinPool来引入自动并行化特定类代码的能力

#### 线程同步的代价
> 线程同步限制了应用的可伸缩性、提高了获得锁的开销
> 
> 同步的内存语义、基于CAS的设施和volatile关键字对性能可能会有很大的影响，特别是在有很多寄存器的大型机上
