# Rust 相关知识点

### 第一章：设计哲学
```mermaid
mindmap
root((设计哲学))
  内存安全
    指导思想
      保证类型安全
      不允许未定义行为
    安全内存管理模型
      所有权系统-所有权指针
      借用和生命周期
        超出生命周期变量自动释放
        借用通过标记生命周期参数，提供给编译器检查，防止出现垂悬指针
    特性
      没有空指针
      默认不可变
      表达式
      高阶函数
      代数数据类型
      模式匹配
      泛型
      trait和关联类型
      本地类型推导
      仿射类型（Affine Type）
      借用、生命周期
  零成本抽象
    抽象在编译期完成，被展开成和手写汇编代码相近的底层代码，运行时没有解释抽象代码的性能开销
  实用性
    实践性-能够应用于开发工业级产品
      提供断言工具用于失败处理
      提供 Option<T> 用于错误处理
      提供线程恐慌机制用于发生异常时安全退出线程
      支持零成本的 FFI 机制：可以兼容与其他语言的相互调用<br/>Unsafe Rust 专门与外部系统交互
      包管理器 Cargo
    有益性-能够对业界产生积极的效果或影响
    稳定性-解决相同问题时不会因为使用者不同而出现随机的结果
  LLVM 编译
    过程：<br/>生成 AST <br/>编译成 HIR <br/>编译成 MIR <br/> 最终被翻译成 LLVM IR，然后被 LLVM 的处理编译成各个平台上运行的目标机器码
    优势
      缩短编译时间
      缩短执行时间
      更精确的类型检查
```

### 第二章：语言精要
```mermaid
mindmap
root(基本构成)
  语言规范
    Rust语言参考
    ::icon(fa fa-book)
    RFC文档
    ::icon(fa fa-book)
  编译器-rustc
    跨平台
    支持交叉编译
    使用 LLVM 作为编译器后端
    包含在 Rust 语言源码中
    对 Rust 代码进行词法语法分析、金泰类型检查，翻译为 LLVM IR
  核心库
    基本的 trait
    基本原始类型
    常用功能型数据类型
    常见宏定义
  标准库
    与核心库一样的基本 trait
    并发、I/O 和运行时
    平台抽象
    底层操作接口
    可选和错误处理类型 Option 和 Result 以及各种迭代器
  包管理器-Cargo
    包管理
    管理整个工作流程
      创建项目
      运行测试
      构建发布链接库
      运行可执行文件
```

```mermaid
mindmap
root(语句与表达式<br/>变量与绑定)
  语句-要执行的操作和产生副作用的表达式
    声明语句-声明各种语言项
      变量
      常量
      结构体
      函数
      引入包和模块
    表达式语句-特指以分号结尾的表达式，求值结果会被舍弃，并总是返回单元类型
  表达式-计算求值
  变量与绑定
  位置表达式-表示内存位置的表达式，支持读写操作
    本地变量
    静态变量
    解引用（*expr）
    数组索引
    字段引用
    位置表达式组合
  值表达式-只进行读操作
  不可变绑定-let声明
  可变绑定-mut声明
  所有权-当位置表达式出现在值上下文中时,该位置表达式会把内存地址转移给另外一个位置表达式
    操作符&-直接获取表达式的内存地址
```

```mermaid
mindmap
root(函数与闭包)
  通过 fn 进行定义
  返回值-return表达式用于返回一个值，如果缺失，就默认返回单元值
  作用域-静态作用域，即词法作用域
    变量遮蔽-从使用let声明创建变量绑定开始，到超出词法作用域的范围时结束
  函数指针-Rust中的一等公民
    函数作为参数
    函数作为返回值
  CTFE机制-编译时函数执行<br/>Compile-Time Function Execution
    const fn
    const generics
  闭包-匿名函数
    可以像函数一样被调用
    可以捕获上下文环境中的自由变量
    可以自动推断输入和返回的类型
    可以捕获外部变量，而函数不可以
    闭包实际上就是由一个匿名结构体和 trait 来组合实现的
```

```mermaid
mindmap
root(流程控制)
  条件表达式-if
  循环表达式
    while
    loop
    for...in
  match 表达式与模式匹配
    match分支使用模式匹配技术（类比 scala）
    match分支左边是模式，右边是执行代码
    绑定模式-使用操作符@可以将模式中的值绑定给一个变量，供分支右侧代码使用
    使用通配符 _ 来穷尽match的每一种可能
  if let
  while let
```

```mermaid
mindmap
root(基本数据类型)
  布尔类型
  数字类型
    固定大小的类型
      无符号整数
        u8（字节字面量的等值类型）
        u16
        u32
        u64
        u128
      符号整数
        i8
        i16
        i32（默认类型）
        i64
        i128
    动态大小的类型
      usize
      isize
    浮点数
      f32
      f64
  字符类型-使用 ‘’ 来定义
  数组类型
    数组大小固定
    元素均为同类型
    默认不可变
    数组的类型签名为 T；N
  范围类型
    左闭右开：1..5
    全闭: 1..=5
  切片类型-对一个数组的引用片段，可以有效访问数组的一部分，不需要拷贝
  str字符串类型
    固定长度字符串
    可增长字符串
  原生指针
    主要用于Unsafe Rust中
    支持不可变原生指针*const T和可变原生指针*mut T
  never类型
    用于表示永远不可能有返回值的计算类型
    never类型可以强制转换为其他任何类型
```

```mermaid
mindmap
root(复合数据类型)
  元组Tuple-类比python
    异构-元组内的元素可以是不同类型
    有限-元组有固定长度
    解构-let （x, y）=Tuple（T, U）
  结构体Struct
    具名结构体：Named-Field Struct
    元组结构体：Tuple-Like Struct
      和元组类型，字段只有类型，没有名字
    单元结构体：Unit-Like Struct
      没有任何字段的结构体
      在 Release 编译模式下，单元结构体实例会被优化为同一个对象
  枚举体Enum
    无参数枚举体
    类C枚举体：带有值
    带参数枚举体：枚举元素为元组结构体
  联合体Union
```

```mermaid
mindmap
root(常用集合类型)
  线性序列
    向量Vec
      可动态增长的数组
    双端队列VecDeque
      先进先出
      后进先出
    双向链表LinkedList
  Key-Value映射表
    无序哈希表HashMap
    有序哈希表BTreeMap
  集合类型
    无序集合HashSet
    有序集合BTreeSet
  优先队列-二叉堆BinaryHeap
```

```mermaid
mindmap
root(其他)
  智能指针
    相关概念
      Rust中的值默认被分配到栈内存
      可以通过 Box 将值装箱，在堆内存中分配
      当 Box 超出作用域范围时<br/>将调用解析函数销毁内部对象，<br/>并自动释放堆中的内存
    定义：Box 的行为像引用，并且可以自动释放内存，称为智能指针
  泛型和trait
    trait 是 Rust 零成本抽象的基石
      trait 是 Rust 唯一的接口抽象方式
      可以静态生成，也可以动态调用
      可以当作标记类型拥有某些特定行为的“标签”来使用
    泛型
  错误处理
    Option 表示值存在的可能性
    Result 表示错误存在的可能性
```

### 第三章：类型系统
```mermaid
mindmap
root(类型系统)
  作用
    排查错误
    抽象
    文档
    优化效率
    类型安全
     可以避免类型间无效计算
     保证内存安全
     避免语义上的逻辑错误
  类型系统的分类
    静态类型-在编译期进行类型检查
    动态类型-在运行期进行类型检查
    强类型-不允许隐式转换
    弱类型-允许隐式转换
    Rust属于显式静态类型
  多态类型系统-允许一段代码在不同的上下文中具有不同的类型
    多态的形式
      参数化多态-一般是静多态，实际上就是指泛型
        泛型函数
        泛型结构体
      Ad-hoc多态-一般是静多态<br/>在不同的上下文中会响应不同的行为实现
        接口抽象
        泛型约束
        抽象类型
          trait对象-装箱抽象类型
          impl Trait-拆箱抽象类型
        标签trait
          Sized trait-标识编译期可确定大小的类型
          Unsize trait-标识动态大小类型DST
          Copy trait-标识可以按位复制其值的类型
          Send trait-标识可以跨线程安全通信的类型
          Sync trait-标识可以在线程间安全共享引用的类型
          可以自定义标签 trait
      子类型多态-一般是动多态
        父类型的值包含了子类型的值，所以子类型的值有时也可以看作父类型的值，反之则不成立
        Rust目前不支持子类型多态
      静多态-编译期多态，是零成本抽象
      动多态-运行时多态
    零散概念
      Rust中一切皆类型
      胖指针-包含了动态大小类型地址信息和携带了长度信息的指针
      零大小类型-单元类型和单元结构体，大小都是零，运行时不占用内存空间
      底类型
        没有值
        是其他任意类型的子类型
        用叹号❗️表示
        面对什么样的情况使用
          发散函数：Diverging Function
          continue 和 break 关键字
          loop 循环
          空枚举
    类型推导
      Rust只能在局部范围内进行类型推导
      Rust无法从上下文自动推导出类型时会提示添加类型标注
  类型转换
    隐式转换
      Deref 解引用
        由编译器执行
        开发者可以定义自动解引用的行为
      手动解引用
    显式转换
      as操作符
      From
      Into
  trait系统的不足
    孤儿规则的局限性
    代码复用的效率不高
    抽象表达能力有待改进
```

### 第四章：内存管理
```mermaid
mindmap
root(内存管理)
  内存管理类型
    手动内存管理-C
    自动内存管理-Java
    既无GC又能安全地进行手动内存管理-Rust
  虚拟内存管理技术
    对物理存储设备的统一抽象
      物理内存
      磁盘
      寄存器
      高速缓存
    方便同时运行多道程序，每个进程都有各自独立的进程地址空间
    虚拟地址空间-线性
      内核空间
      用户空间
    栈内存-虚拟内存空间中支持CPU入栈或出栈指令操作的内存部分，保存函数调用所要维护的信息
    栈帧-存储每次函数调用所需信息的记录单元
      函数的返回地址和参数
      临时变量
      保存的上下文
    堆内存-存储方便跨函数使用的数据，生命周期比栈内存长
    堆分配算法
      空闲链表
      位图标记
    Rust编译器自带分配器
      alloc_system
      alloc_jemalloc
        分配或回收内存更快速
        内存碎片更少
        多核友好
        良好的可伸缩性
    内存布局
      内存对齐，也叫字节对齐
        基本数据对齐
        结构体数据对齐
  Rust中的资源管理
    变量
      全局变量
        常量变量
        静态变量-和程序代码一起被存储在静态存储区
      局部变量-函数中定义的变量，默认存储到栈中
    对变量的检查-检查是否生命未初始化变量
      检测分支流程是否产生未初始化变量
      检测循环中是否产生未初始化变量
      空数组或向量可以初始化变量
      转移所有权产生未初始化变量
    智能指针与RAII
      智能指针区别与常规结构体的特性在于，它实现了Deref和Drop这两个trait
        Deref 提供了自动解引用的功能
        Drop 提供了自动析构的功能
          释放堆内存
          释放文件和网络链接
          功能类似GC，可以回收内存及内存之外的一切资源
      确定性析构-RAII-Resource Acquisition Is Initialization
        Rust中的常用类型均实现了 Drop，所以Rust会自动完成析构动作
    使用Valgrind来检测内存泄漏
    内存泄漏与内存安全
      内存泄漏
        并不能百分百地阻止内存泄漏
        不能轻而易举地造成内存泄漏
      内存安全的定义
        不使用未定义内存
        没有空指针
        没有垂悬指针-堆内存已被释放，但是其本身还没有做任何处理，依旧指向已回收内存地址的指针
        没有缓存区溢出
        不会非法释放未分配的指针或已经释放过的指针
      内存泄漏的原因
        线程崩溃，析构函数无法调用
        使用引用计数时造成了循环引用
        调用Rust标准库中的forget函数主动泄漏
    复合类型的内存分配和布局-复合类型的实例主要看如何使用来分配内存
```

### 第五章：所有权系统
```mermaid
mindmap
root(所有权系统)
  值的分类
    值类型-数据直接存储在栈中的数据类型
    引用类型-数据存储在堆中，栈中只存放指向堆中数据的地址
    值语义-按位复制之后，与原始对象无关
    引用语义-禁止按位复制
  绑定、作用域和生命周期
  所有权借用
    借用的生命周期不能长于出借方
    可变借用不能有别名，可变借用具有独占性
    不可变借用不能再次出借为可变借用
  生命周期参数
    生命周期参数必须以单引号开头，参数名通常是小写字母: 'a
    标注生命周期参数并不能改变任何引用的生命周期长短，只能用于编译器的借用检查，防止垂悬指针
    显式生命周期参数
  智能指针与所有权
    智能指针拥有资源的所有权
    共享所有权 Rc 和 Weak
    内部可变性 Cell 和 RefCell
    写时复制 Cow
  并发安全与所有权
    如果类型 T 实现了 Send，就是告诉编译器该类型的实例可以在线程间安全传递所有权
    如果类型 T 实现了 Sync，就是向编译器表明该类型的实例在多线程并发中不可能导致内存不安全，可以安全地跨线程共享
  非词法作用域生命周期
    基于MIR的借用检查：MIR是基于控制流图的抽象数据解构，用有向图形式包含了程序执行过程中的所有可能的流转
      基本块
      语句
      终止句
      本地变量
      位置
      右值
```

### 第六章：函数、闭包和迭代器
```mermaid
mindmap
root(函数、闭包和迭代器)
  函数
    蛇形命名法
    除函数体之外的函数声明被称为函数签名
    按值传递的参数使用mut关键字，mut关键字被放到参数变量前面
    按引用传递参数时使用 &mut，并将其放到参数变量后面
    函数屏蔽
      作用域内的函数会屏蔽掉作用域外的同名函数
    函数参数模式匹配
      函数参数支持模式匹配
      使用通配符忽略参数
      函数参数利用模式匹配来解构元组
    函数返回值
      Rust 中的函数只能有唯一的返回值，即便没有显式返回值的函数，也返回了一个单元值
      可以使用元组类型进行返回，这点类似 Python
    泛型函数
    方法与函数
      方法在 Rust 中代表某个实例对象的行为
      函数在 Rust 中是一段简单的代码
    高阶函数-以函数作为参数或返回值的函数，是函数式编程语言的基础特性
  闭包
    定义：通常指词法闭包，是一个持有外部环境变量的函数
      外部环境指闭包定义时所在的词法作用域，也称为自由变量
      将自由变量和自身绑定的函数就是闭包
    特性
      延迟执行
      捕获环境变量
    基本语法
      由管道符和花括号组成，管道符里时闭包的参数，花括号里是闭包函数的执行体
      两个相同定义的闭包并不属于同一类型
    闭包与所有权
      如果闭包中没有捕获任何环境变量，默认自动实现 Fn trait
      如果闭包中捕获了复制语义类型的环境变量，则
        如果不需要修改环境变量，无论是否使用 move 关键字，均会自动实现 Fn
        如果需要修改环境变量，则自动实现 FnMut
      如果闭包中捕获了移动语义类型的环境变量，则
        如果不需要修改环境变量，且没有使用 move 关键字，则自动实现 FnOnce
        如果不需要修改环境变量，且使用了 move 关键字，则自动实现 Fn
        如果需要修改环境变量，则自动实现 FnMut
      使用 move 关键字，如果捕获的变量是复制语义类型的，则闭包会自动实现 Copy/Clone，否则不会自动实现 Copy/Clone
    闭包作为函数参数和返回值
      闭包作为 trait 对象
      闭包作为函数参数
      函数指针也可以作为闭包参数
      闭包作为函数返回值
    高阶生命周期
  迭代器
    分类
      内部迭代器-通过迭代器自身来控制迭代下一个元素，外部无法干预，必须等待迭代器依次为其中的每个元素执行完相关操作后才可以停止遍历
      外部迭代器-独立于容器之外，通过容器提供的方法来迭代下一个元素，外部可以控制整个遍历进程
    迭代器适配器
      Map适配器-通过对原始迭代器中的每个元素调用指定的闭包来产生一个新的迭代器
      Chain适配器-通过连接两个迭代器来创建一个新的迭代器
      Cloned适配器-通过拷贝原始迭代器中的全部元素来创建新的迭代器
      Cycle适配器-创建一个永远循环迭代的迭代器，当迭代完毕后，再返回第一个元素开始迭代
      Enumerate迭代器-创建一个包含计数的迭代器，同 Python
      Filter迭代器-创建一个基于谓词判断式过滤元素的迭代器
      FlatMap-创建一个类似Map的解构迭代器，但是其中不会包含任何嵌套
      Fuse-创建一个可以快速结束的迭代器，在遍历迭代器时，只要返回过一次None，之后所有的遍历结果就都为None
      Rev-创建一个可以反向遍历的迭代器
      支持自定义适配器
  消费器
    any-查找容器中是否存在满足条件的元素
    fold-接受两个参数，第一个为初始值，第二个为带有两个参数的闭包，reduce
    collect-将迭代器转换为指定的集合类型
```

### 第七章：结构化编程
```mermaid
mindmap
root(结构化编程)
  对面向对象编程风格的支持
    封装
      结构体
      枚举体
    多态
      trait
      泛型
      枚举体
    代码复用
      泛型单态化
      trait对象
      宏
      语法扩展
      代码生成
  结构体
    代数数据类型 ADT - Algebraic Data Type
      指具备了代数能力的数据类型，可以进行代数运算并满足一定的运算规则
      积类型-乘法原理
  常用设计模式
    设计模式的思想
      针对接口编程-trait可以强制性地实现针对接口编程
      组合优于继承-泛型和trait限定可替代继承实现多态
      分离变和不变-类型系统天生分离了变与不变
      委托代替继承-常用的迭代器利用委托来代替继承
    模式
      建造者模式
      访问者模式
        包含需要操作的元素
        定义相关的操作
      RAII模式
```

### 第八章：字符串与集合类型
```mermaid
mindmap
root(字符串与集合类型)
  字符串
    字符编码-将字符集中码位转换为字节序列的过程，称为编码
    解码-将字节序列转换成字符集中码位的过程
  字符-char
  字符串分类
    str-表示固定长度的字符串
    String-表示可增长的字符串
    CStr-表示由C分配而被Rust借用的字符串，用于与C语言交互
    CString-表示由Rust分配且可以传递给C函数使用的C字符串
    OsStr-表示和操作系统相关的字符串，兼容Windows系统
    OsString-表示OsStr的可变版本
    Path-表示路径，包装了OsStr
    PathBuf-与Path配对，是Path的可变版本，包装了OsString
    &str-str的切片类型，是不可变的UTF-8字节序列，创建后无法再为其追加内容或更改其内容，可以存储在
      静态存储区
      堆分配
      栈分配
  字符串的处理方式
    按字节处理
    按字符处理
  字符串修改
    追加
    插入
    连接
    更新
    删除
  字符串查找
    存在性判断：contains starts_with ends_with
    位置匹配：find rfind
    分割字符串：split rsplit split_terminator rsplit_terminator splitn rsplitn
    捕获匹配：matches rmatches match_indices rmatch_indices
    删除匹配：trim_matches trim_left_matches trim_right_matches
    替代匹配：replace replacen
```

### 第九章：构建健壮的程序
```mermaid
mindmap
root(健壮的程序)
  保证健壮性的方法
    返回错误值
    异常
      栈回退 Stack Unwind
      栈回溯 Stack Backtrack
  非正常状况
    失败-违反了“契约”的行为
    错误-在可能出现问题的地方出现了问题
    异常-完全不可预料的问题
  消除失败
    强大的类型系统
    断言
  分层处理错误
   Option 用于处理有和无的情况
   Result 用于处理可以合理解决的问题
   线程恐慌 Panic 用于处理无法合理解决的问题
   程序中止 Abort 用于处理会发生灾难性后果的情况
```

### 第十章：模块化编程
```mermaid
mindmap
root(模块化编程)
  模块化优点
    增强维护性
    隔离性
    代码复用
  Rust对模块化的支持
    包管理工具 Cargo
    第三方包 crate
    所有第三方包都可以在 GitHub 上找到，并可以通过 Cargo 直接发布到包仓库平台 crate.io 上
  Cargo 的工作内容
    使用两个元数据metadata文件来记录各种项目信息
      Cargo.toml 由开发者编写，从广义上描述项目所需要的各种信息，包括第三方包的依赖
      Cargo.lock 只记录依赖包的详细信息，由 Cargo 自动维护
    获取并构建项目的依赖关系
      lazy_static
      指定第三方包的依赖关系
    使用正确的参数调用rustc或其他构建工具来构建项目
    为 Rust 生态系统开发建立了统一标准的工作流
    通过 Cargo 提供的命令可以很方便地管理包
  Rust 支持的测试类型
    单元测试
    文档测试
    集成测试
    基准测试-专门用于性能测试
  可见性和私有性
```

### 第十一章：安全并发
```mermaid
mindmap
root(安全并发)
  并发 vs 并行
    并发-同时应对（Dealing With）多件事情的能力，在不同的时间片内交替完成多个任务
    并行-同时执行（Doing）多件事情的能力
  多进程 vs 多线程
    进程是资源分配的最小单元
    线程是程序执行时的最小单元
  事件驱动
    事件驱动编程是为了解决单台服务器要同时处理10K量级的并发连接而提出的技术
    Linux 退出 epoll
  协程
    协程为协同任务提供了一种抽象，这种抽象本质上就是控制流的出让和恢复
    应用场景
      goroutines
      Erlang的轻量级进程 LWP
      Python
      Ruby
      JavaScript
    Rust 支持协程
      以线程为容器
      内存占用比线程更小
      上下文切换开销更小
      没有昂贵的系统内核调度
  线程安全
    线程是对底层硬件运行过程的直接抽象
    优点
      很多编程语言都提供了支持
      没有对线程的使用方式加以限制
      充分利用多核
    缺点
      线程的调度完全由系统内核来控制，完全随机，运行顺序无法预测
      编写正确的多线程并发程序对开发者要求太高，容易 bug 并且难以重现和调试
    多线程存在问题主要是因为资源共享
    线程同步
      锁
      信号量 Semaphores
      屏障 Barrier
      条件变量 Condition Variable
    多线程容易出错的点
      开发者可能忘记加锁
      可能出现死锁
      多线程程序难以调试，出现问题难以复现
  线程管理
    每个线程都有自己的栈和本地状态
    使用 thread::Builder 来定制线程
    线程本地存储 TLS
    底层同步原语
    Send 和 Sync
    多线程共享内存并非线程不安全的问题所在，问题在于错误地共享数据
  原子类型的内存顺序
    排序一致性顺序：Ordering::SeqCst
    自由顺序：Ordering::Relaxed
    获得-释放顺序：Ordering::Release, Ordering::Acquire, Ordering::AcqRel
  通过 Channel 进行线程间通信
    消息通信的并发模型
      Actor 模型
      CSP 模型-通过 Channel 进行通信
    Rust 中的 Channel
      异步无界 Channel，理论上缓冲区是无限的
      同步有界 Channel
      Channel 死锁
  线程池
    工作线程：用于处理具体任务的线程
    线程池初始化：通过设置参数指定线程池的初始栈大小、名称、工作线程数等
    待处理任务的储存队列：存储来不及处理的任务
    线程池管理：管理线程池中的任务数和工作线程状态
  Rayon-执行并行任务
    并行迭代器
    join方法，并行处理递归或分治风格的问题
  Crossbeam
    用于增强 std::sync 的原子类型
    对标准库 thread 和各种同步原语进行扩展
    提供了 MPMC 的 channel，以及各种无锁并发数据结构
    提供了并发数据结构中需要的内存管理组件 crossbeam-epoch
  异步并发
    生成器
    Future 并发模式
    async/await
  数据并行
    计算机系统结构
      SISD-Single Instruction Single Data
      SIMD-Single Instruction Multiple Data
      MISD
      MIMD
```

### 第十二章：元编程
```mermaid
mindmap
root(元编程)
  分类
    简单文本替换
    类型模板
    反射
    语法扩展
    代码自动生成-go generate
  反射
    std::any::Any
    通过is函数判断类型
    转换到具体类型
      downcast_ref
      downcast_mut
    非静态生命周期类型
  宏系统
    Rust中宏的类型
      声明宏
      过程宏
      调用宏
      属性宏
      内置宏
      自定义宏
    编译过程
      分词阶段：将源码分为一系列的词条
      解析阶段：将词条解析为抽象语法树 AST
      提炼 HIR：提炼简化抽象语法树，得到高级中间语言
      提炼 MIR：剔除一些不必要元素
      转译为 LLVM IR
      生成机器码
  编译器插件
    register_syntax_extension：通过它实现任何语法扩展
    register_custom_derive: 专门用于实现自定义派生属性
    register_macro: 实现 Bang 宏
    register_attribute: 实现编译器属性
```

### 第十三章：超越安全的边界
```mermaid
mindmap
root(Unsafe Rust)
  Unsafe Rust 是 Safe Rust 的超集
  unsafe块中使用引用依旧会进行借用检查
  Unsafe Rust-不提供对以下操作的安全检查
    解引用裸指针
    调用 unsafe 的函数或方法
    访问或修改可变静态变量
    实现 unsafe trait
    读写 Union 联合体中的字段
  Unsafe Rust 与 Safe Rust 的区分
    Unsafe Rust 由于不需要安全检查，意味着有一定性能提升
    Unsafe Rust 内存安全完全由开发者保证，否则会出现未定义行为
    区分了编译器和开发者的责任，如果有问题优先排查 Unsafe Rust 的代码
  Unsafe 语法
    unsafe 关键字-用于标记函数、方法和trait
    unsafe 块-用于执行 Unsafe Rust 允许的五种操作
  原生指针
    *const T 和 *mut T
    并不保证指向合法的内存
    不能像智能指针那样自动清理内存，需要手动管理
    没有生命周期的概念
    不能保证线程安全
  Unsafe 与恐慌安全
  混合代码内存安全架构三大原则
    不安全的组件不应该削弱其安全性，特别是公共的 API 和数据结构
    不安全的组件应该尽量小，并于安全组件分离
    不安全的租金啊应该明确标记并轻松升级
  Rust 与 WebAssembly
    WebAssembly 是一种新的字节码格式
    WebAssembly 相当于是一种中间语言，在客户端提供了一种接近本地运行速度的多种语言编写代码的方式
    WebAssembly 规范层级
      核心层-定义模块及其指令集的语义
      API层-定义应用程序接口
    WebAssembly 要点
      模块-基本编译单位，一个.wasm文件就是一个模块
      线性内存-用于和 JavaScript通信，是一个可变大小的 ArrayBuffer，由 JavaScript 分配，WebAssembly 提供了对其进行操作的指令
      表格-用于存放函数引用，支持动态调用函数
      实例-模块的实例包括其在运行使用的所有状态，比如内存、表格和一系列值；同一模块的实例可以共享相同的内存和表格
      栈式机器-每种类型的指令都是在栈上进行出栈和入栈操作
    WebAssembly 生态
      wasm-bindgen： 促进 JavaScript 和 Rust 自己拿使用 wasm 进行通信
      wasm-pack：一站式构建、发布 Rust 编译的 wasm 到 npm 平台
      cargo-generate: 直接生成 wasm-bindgen 和 wasm-pack 项目模版
```